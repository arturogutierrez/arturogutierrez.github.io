---
layout: post
title: Creating an efficient Leaderboard
comments: true
permalink: "creating-an-efficient-leaderboard"
---

Finally I've decided to have a blog, a technical blog, to try to share things what I considered relevant to read, relevant for me at least :)

I'm going to start about how I developed an online Leaderboard in an efficient way. I used [Parse][parse] to do it but you can take the idea and implement it with SQL, MongoDB or whatever you want.
About [Parse][parse], if you don't know it you should know it's a great tool to create the backend side of your mobile app with no worries about databases, performance, or scaling.

To give some context, I'm Android and iOS developer but I also create some games for Android in my spare time and all of them used a service called [Scoreloop][scoreloop] which offered User management, Leaderboards, Challenges and Achievements as main features but [RIM][rim] purchased the company to close it on 1st December 2014 so that led me to the next problem: what can I do with my games? Can I use a new service which I hope offers the same feature and pray that won't be closed? Or can I develop my own game service to customize it for my games? You can imagine my answer but I don't know much about create backend services so I did a small research and I found [Parse][parse] and I can't be more pleased with them.

# Target

I wanted to create a online Leaderboard for my games which should had the following requisites:

* **Multiple game modes support**
* **Support for millions of users**
* **Should be Fast**
* **User ranking**

![gamehoop-leaderboard]

No more talk, lets get on with it!.

# First Approach

First idea, have a **Score** class (Parse's classes are like Tables in SQL or Collection in MongoDB) where saving every score generated by the users.

![parse-score-class]

   * **objectId**: Unique id generated by Parse.
   * **user**: Pointer to the user whose belongs the `Score`.
   * **gameMode**: Game mode which belongs this `Score`.
   * **score** and **minorScore**: My game scores have two components and they should be sorted first by score and then by minorScore.

Seems good right? Only left querying the class to retrieve the leaderboard. Note: For security reasons which are not the purpose of this blog entry I execute all queries on server using [Cloud Code][cloud-code].

```js
  var gameModeId = ....

  var query = new Parse.Query('Score');
  query.select(['user', 'score', 'minorScore'])
  query.equalTo('gameMode', gameModeId);
  query.addDescending(['score', 'minorScore', 'createdAt']);
  query.find().then(function(scores) {
    response.success(scores);
  }, function(err) {
  	response.error(...)
  });
```

That's all, our Leaderboard is working but advanced audience will have noticed that there is some problems with this approach.

  * **What would happen if we have multiple scores per user**? We'll get a Leaderboard with duplicated users.
  * **What would happen if we have millions of Scores**? The query only returns up to 1.000 entries. OK, yes, we can add a pagination to avoid the limitation but, will be the query fast? No, it'll be **extremely slow**, sorting millions of rows per request is not a good idea...

# Second Approach 

Ok, we have to fight with the previous issues (the slow query and duplicated users) so a new class comes into the scene: `Leaderboard`.

![leaderboard-score-class]

   * **user**: Pointer to the user whose belongs the row.
   * **gameMode**: Game mode which belongs this row.
   * **highestScore**: Pointer to the best `Score` of the user.
   * **score** and **minorScore**: Same information than `highestScore` used in the new query. If we have the score information as class fields we don't need to go to another class to retrieve the information and the **query will be faster**.

The idea of this class is to have **only one row per user** and per game mode. This way we can do a simple query to retrieve the leaderboard for a given game mode, [Parse][parse] will have to sort them but it will be fast because the size of this table will be infinitely smaller than ``Score`` table.

We have to add more Server code in order to populate the table. We'll add an [afterSave trigger][aftersave-trigger] on Score class to execute our logic when a new score is created.

```js
var Leaderboard = Parse.Object.extend("Leaderboard");

Parse.Cloud.afterSave('Score', function(request) {
  var user = Parse.User.current(),
      gameMode = request.object.get('gameMode'),
      scoreObject = request.object;
  
  var query = new Parse.Query('Leaderboard');
  query.equalTo('user', user);
  query.equalTo('gameMode', gameMode);
  query.limit(1);
  query.first({
    success: function(leaderboardObject) {
      if (leaderboardObject) {
      	// Update previous if the score is better
        var score = scoreObject.get('score');
        var minorScore = scoreObject.get('minorScore')
        var previousScore =  leaderboardObject.get('score');
        var previousMinorScore = leaderboardObject.get('minorScore')
        // I'm using my own function to compare two scores
      	if (compareScore(score, minorScore,
      		previousScore, previousMinorScore) > 0) {
          leaderboardObject.set('highestScore', scoreObject);
          leaderboardObject.set('score', score);
          leaderboardObject.set('minorScore', minorScore);
          leaderboardObject.save();
      	}
      } else {
      	// The user doesn't have a Score yet so will create a new one
        var newLeaderboard = new Leaderboard();  
        newLeaderboard.set('user', user);
        newLeaderboard.set('highestScore', scoreObject);
        newLeaderboard.set('gameMode', gameMode);
        newLeaderboard.set('score', score);
        newLeaderboard.set('minorScore', minorScore);
        newLeaderboard.save();
      }
    },
    error: function(error) {
      console.log('Error querying Leaderboard blah blah blah');
    }
  });
});
```

Easy, right? We have our `Leaderboard` class populated automatically with right values now so we only have to query on it to retrieve the Leaderboard in real time, we'll add pagination support this time.

```js
  var query = new Parse.Query('Leaderboard');
  query.select(['user', 'score', 'minorScore'])
  query.equalTo('gameMode', gameModeId);
  query.addDescending(['score', 'minorScore', 'createdAt']);
  query.limit(length);
  query.skip(length * page);
  query.find().then(function(scores) {
    response.success(scores);
  }, function(err) {
  	response.error(...)
  });
```

Finally we have our leaderboard working in a **efficient way** avoiding some [Parse][parse] limitations. Probably this is enough for many projects but I needed more, I need the rank position for a given user and that is not an easy problem to resolve. Well, it's easy to resolve if you don't mind about speed and you have unlimited CPUs (aka server machines) to count all scores better than the score from the user given per request.
Returning to the real world we have to find a way to know the ranking of an user and it should be quick and cheaper.

# Calculating Rank Position

As said before we could do a query of all Scores better than a given score and count them. [Parse][parse] has a `Count` function to do that but it's slow because it has to go to disk to count rows and what happen if the user's rank is 25.437th? and if there are several users requesting their rank? Obviously [Parse][parse] won't die but you will get an error on almost all queries and, excluding errors, we want to add the feature in an efficient and smart way.

So, how can we do it?. I had the idea of using counters per score ranges, I called each counter as `Bucket`. The idea is counting how many scores there is in a range of scores on `Leaderboard` and save the count in the bucket.

![parse-buckets]

First, we have to be clear **how to distribute the ranges of the scores**, it depends of each game but, in my case, I know what is the minimum and maximum score so I can distribute them linearly although the best way would be know how the user scores will be distributed and create them accordingly.

We have two possibilities to create the buckets before using them:

  * Create them dynamically when will be necessary.
  * Or create them previously. This is the approach I took to save some complexity but both approach are absolutely valid.

Once buckets are created we need to add some easy code on `Score.afterSave` trigger looking for the bucket which belongs the new Score if it's a new highest score and incrementing the counter, we also have to decrement the previous bucket counter if there was a previous score otherwise will increase the rankings in wrong way.

![parse-afterscore-flow]

Brief summary about what new code have to add to the `Score.afterSave`trigger:

```js
  // Get previous bucket if there was a previous highest score
  var previousBucket = ...
  // Query for the bucket where:
  //    bucket.minScore < newScore <= bucket.maxScore
  var newBucket = ... 
  if (previousBucket) {
    previousBucket.increment('count', -1);
    previousBucket.save();
  }
  newBucket.increment('count', 1);

  // Save a pointer for the bucket to speed up the rank query
  newScore.set('bucket', newBucket);

  Parse.Object.saveAll(newScore, newBucket);
```

Now, we have our `Bucket` class filled and working smoothly so we have to develop the code which calculate the ranking for a given user. It's not a hard algorithm but several things are needed to do.

![parse-rank-flow]

 1. User ask for his ranking
 2. We query `Leaderboard` class to get his `Score` for a given game mode.
 3. Having a pointer for the bucket on `Leaderboard` class we can access to the bucket directly.
 4. We need to do two queries more in order to know the ranking.
   - First, we need to retrieve all buckets which stores better scores than the user score bucket and sum all `count` field, this means we know how many scores are better at least: `minRank`.
   - Second, our score belongs to one bucket that means the score can be the best, the worst or another one so we have to know which is the position in the bucket. To do that we need to retrieve our `Leaderboard` as we did before but limiting scores to `bucket.minScore` and `bucket.maxScore`, the row count will be `rankInBucket`
 5. Finally, `rank = minRank + rankInBucket`

That's is all, we are able to calculate the ranking of an user, this is very useful when you are showing the top leaderboard and you also want to show to your user where he is positioned.

**Pros**

  * We can calculate the Rank with 3 fast queries instead of one impossible query to run.
  * The complexity is not so high and the space required to keep the counters is very small.

**Cons**

  * We have to know how to distribute our scores accordingly.
  * The last query to know the position in a bucket can be slow if our buckets are so big and we have a lot of users in each bucket.


# Improvements

 About last issue, it can be avoided if we improve our systems creating several levels of the buckets. For example, we can have a parent bucket with stores scores (0, 100) and 10 child buckets with stores (0, 10], (10, 20], (20, 30], etc... We're increasing the complexity but we are speeding more our queries because we can have less parent buckets (speeding up our `minRank` query) and the algorithm will be much the same. About levels, you can increment as levels as you need but you have to keep in mind if more levels will speed up your calculates or not... 

 I've implemented my buckets in two levels, you can see how my `LeaderboardBucket` class look like:

![parse-leaderboard-buckets-class]


Other way to improve the system is **keeping the buckets always on memory** so I won't have to query the table two times doing the system go to disk (I don't know really, depends on [Parse][parse] implementation) but I can't implement it on [Parse][parse] this way but maybe you can do it on your system if you are using to your own backend yo implement your Leaderboard.

# Conclusion

I don't know if this is the best architecture to implement a Leaderboard in an efficient way but I think **it's a beginning** at least especially using [Parse][parse] as backend.

If you have any questions or comments, please post them below.
If you liked this post, you can
<a href="https://twitter.com/intent/tweet?url=http://arturogutierrez.github.io{{ page.url }}&text={{ page.title }}&via={{ site.twitter_username }}" 
   target="_blank">
  share it with your followers</a> 
or 
<a href="https://twitter.com/{{ site.twitter_username }}">
  follow me on Twitter</a>!

<a href="https://twitter.com/share" class="twitter-share-button" data-url="http://arturogutierrez.github.io{{ page.url }}" data-via="{{ site.twitter_username }}" data-size="large">Tweet</a>

<!-- Put this just before the closing body tag -->
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>


[parse]: https://parse.com
[scoreloop]: http://www.scoreloop.com/
[rim]: http://www.blackberry.com/
[cloud-code]: https://parse.com/docs/js/guide#cloud-code
[aftersave-trigger]: https://parse.com/docs/js/guide#cloud-code-aftersave-triggers

[gamehoop-leaderboard]: /public/images/gamehoop_leaderboard.png
[parse-score-class]: /public/images/parse_score_class.png
[leaderboard-score-class]: /public/images/parse_leaderboard_class.png
[parse-buckets]: /public/images/parse_buckets.png
[parse-afterscore-flow]: /public/images/parse_afterscore_flow.png
[parse-rank-flow]: /public/images/parse_rank_flow.png
[parse-leaderboard-buckets-class]: /public/images/parse_buckets_two_levels.png

[twitter]: https://twitter.com/{{ site.twitter_username }}
[github]: https://github.com/{{ site.github_username }}

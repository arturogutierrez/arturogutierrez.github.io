---
layout: post
title: Creating a Leaderboard with Parse in a efficient way
---

Finally I've decided to have a blog, a technical blog, to try to share things what I considered relevants to read, relevants for me at least :)

I'm going to start about how I developed a real time Leaderboard with [Parse][parse] in a efficient way. If you don't know it you should know it's a great tool to create the backend side of your mobile App with no worries about databases, performance, or scaling.

To give some context, I also create some games in my spare time and all of them used a service called [Scoreloop][scoreloop] which offered User management, Leaderboards, Challenges and Achievements as main features but [RIM][rim] purchased the company to close it on 1st December 2014 so that led me to the next problem: what can I do with my games? Can I use a new service which I hope offers the same feature and pray that won't be closed? Or can I develop my own game service to customize it for my games? You can imagine my answer but I don't know much about create backend services so I did a small research and I found [Parse][parse] and I can't be more pleased with them.

No more talk and let get on with it.

# First Approach

First idea, have a **Score** class (Parse's classes are like Tables in SQL or Collection in MongoDB) where saving every score generated by the users.

![parse-score-class]

   * **objectId**: Unique id generated by Parse.
   * **user**: Pointer to the user whose belongs the `Score`.
   * **gameMode**: Game mode which belongs this `Score`.
   * **score** and **minorScore**: My game scores have two components and they should be sorted first by score and then by minorScore.

Seems good right? Only left querying the class to retrieve the leaderboard. Note: For security reasons which are not the purpose of this blog entry I execute all queries on server using [Cloud Code][cloud-code].

```js
  var gameModeId = ....

  var query = new Parse.Query('Score');
  query.select(['user', 'score', 'minorScore'])
  query.equalTo('gameMode', gameModeId);
  query.addDescending(['score', 'minorScore', 'createdAt']);
  query.find().then(function(scores) {
    response.success(scores);
  }, function(err) {
  	response.error(...)
  });
```

That's all, our Leaderboard is working but advanded audience will have noticed that there is some problems with this approach.

  * **What would happen if we have multiple scores per user**? We'll get a Leaderboard with duplicated users.
  * **What would happen if we have millions of Scores**? The query only returns up to 1.000 entries. Ok, yes, we can add a pagination to avoid the limitation but, will be the query fast? No, it'll be **extremely slow**, sorting millions of rows per request is not a good idea...

# Second Approach 

Ok, we have to fight with our slow query and the duplicated users so `Leaderboard` class comes into the scene.

![leaderboard-score-class]

   * **user**: Pointer to the user whose belongs the row.
   * **gameMode**: Game mode which belongs this row.
   * **highestScore**: Pointer to the best `Score` of the user.
   * **score** and **minorScore**: Same information than `highestScore` used in the new query. If we have the score information as class fields we don't need to go to another class to retrieve the information and the **query will be faster**.

The idea of this class is to have **only one row per user** and per game mode. This way we can do a simple query to retrieve the leaderboard for a given game mode, Parse will have to sort them but it will be fast because the size of this table will be infinitely smaller than ``Score`` table.

We have to add some Cloud Code on Parse to maintain this table, we'll add an afterSave trigger on Score class to execute our logic when a new Score is created.

```js
var Leaderboard = Parse.Object.extend("Leaderboard");

Parse.Cloud.afterSave('Score', function(request) {
  var user = Parse.User.current(),
      gameMode = request.object.get('gameMode'),
      scoreObject = request.object;
  
  var query = new Parse.Query('Leaderboard');
  query.equalTo('user', user);
  query.equalTo('gameMode', gameMode);
  query.limit(1);
  query.first({
    success: function(leaderboardObject) {
      if (leaderboardObject) {
      	// Update previous if the score is better
        var score = scoreObject.get('score');
        var minorScore = scoreObject.get('minorScore')
        var previousScore =  leaderboardObject.get('score');
        var previousMinorScore = leaderboardObject.get('minorScore')
      	if (compareScore(score, minorScore,
      		previousScore, previousMinorScore) > 0) {
          leaderboardObject.set('highestScore', scoreObject);
          leaderboardObject.set('score', score);
          leaderboardObject.set('minorScore', minorScore);
          leaderboardObject.save();
      	}
      } else {
      	// The user doesn't have a Score yet so will create a new one
        var newLeaderboard = new Leaderboard();  
        newLeaderboard.set('user', user);
        newLeaderboard.set('highestScore', scoreObject);
        newLeaderboard.set('gameMode', gameMode);
        newLeaderboard.set('score', score);
        newLeaderboard.set('minorScore', minorScore);
        newLeaderboard.save();
      }
    },
    error: function(error) {
      console.log('Error querying Leaderbord blah blah blah');
    }
  });
});
```

Easy, right? We have our `Leaderboard` class populated automatically with right values now so we only have to query on it to retrieve the Leaderboard in real time, we'll add pagination support this time.

```js
  var query = new Parse.Query('Score');
  query.select(['user', 'score', 'minorScore'])
  query.equalTo('gameMode', gameModeId);
  query.addDescending(['score', 'minorScore', 'createdAt']);
  query.limit(length);
  query.skip(length * page);
  query.find().then(function(scores) {
    response.success(scores);
  }, function(err) {
  	response.error(...)
  });
```

Finally we have our leaderboard working in a **efficient way** avoiding some Parse limitations. Probably this is enough for many projects but I needed more, I need the rank position for a given user and that is not a easy problem to resolve. Well, it's easy to resolve if you dont mind about speed and you have unlimited CPUs (aka server machines) to count all scores better than the score from the user given per request.
Returning to the real world we have to find a way to know the ranking of a user and it should be quick and cheaper.

# Calculating Rank Positions


[parse]: https://parse.com
[scoreloop]: http://www.scoreloop.com/
[rim]: http://www.blackberry.com/
[cloud-code]: https://parse.com/docs/js/guide#cloud-code

[parse-score-class]: /public/images/parse_score_class.png
[leaderboard-score-class]: /public/images/parse_leaderboard_class.png